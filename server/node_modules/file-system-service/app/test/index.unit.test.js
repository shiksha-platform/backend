'use strict';

const FileSystemService = require('.');
const _ = require('lodash');
const assert = require('assert');
const expectError = require('expect-error');
const fs = require('fs');
const invertPromise = require('promise-inverter');
const sinon = require('sinon');

describe('FileSystemService', () => {
    const sandbox = sinon.sandbox.create();

    const testString = '\t  ---- PERHAPS PRIVATE KEY ----\n\n';
    const trimmedTestString = '---- PERHAPS PRIVATE KEY ----';
    const jsonTestString = '\t  {\n    "foo": "bar"\n}\n\n';
    const parsedJsonTestString = { foo: 'bar' };

    describe('#constructor', () => {
        it('no argument', () => {
            new FileSystemService();
        });
    });

    describe('#readFile', () => {
        before(mockUTF8FileSystemToReturn({ 'myFile.txt': testString }));
        after(unmock);

        it('myFile.txt (an existing file)', () => new FileSystemService()
            .readFile('myFile.txt')
            .then(actual => assert.equal(actual, trimmedTestString)));

        it('myOtherFile.txt (an nonexistent file)', () => invertPromise(new FileSystemService()
            .readFile('myOtherFile.txt'))
            .then(err => assert.equal(err.message, 'Could not read file: "myOtherFile.txt"')));

        it('missing argument', () => invertPromise(new FileSystemService()
            .readFile())
            .then(err => assert.equal(err.message, 'Could not read file: "undefined"')));
    });

    describe('#readFileSync', () => {
        before(mockUTF8FileSystemToReturn({ 'myFile.txt': testString }));
        after(unmock);

        it('myFile.txt (an existing file)', () => {
            const actual = new FileSystemService().readFileSync('myFile.txt');
            assert.equal(actual, trimmedTestString);
        });

        it('myOtherFile.txt (an nonexistent file)', () => {
            const err = expectError(() => {
                new FileSystemService().readFileSync('myOtherFile.txt');
            });
            assert.equal(err.message, 'Could not read file: "myOtherFile.txt"');
        });

        it('missing argument', () => {
            const err = expectError(() => {
                new FileSystemService().readFileSync();
            });
            assert.equal(err.message, 'Could not read file: "undefined"');
        });
    });

    describe('#readJsonFile', () => {
        before(mockUTF8FileSystemToReturn({
            'myFile.txt': testString,
            'myJsonFile.json': jsonTestString,
        }));
        after(unmock);

        it('a valid JSON file', () => new FileSystemService()
            .readJsonFile('myJsonFile.json')
            .then(actual => assert.deepEqual(actual, parsedJsonTestString)));

        it('an invalid JSON file', () => invertPromise(new FileSystemService()
            .readJsonFile('myFile.txt'))
            .then(err => assert.equal(err.message, 'Invalid JSON file: "myFile.txt"')));
    });

    describe('#readJsonFileSync', () => {
        before(mockUTF8FileSystemToReturn({
            'myFile.txt': testString,
            'myJsonFile.json': jsonTestString,
        }));
        after(unmock);

        it('a valid JSON file', () => {
            const actual = new FileSystemService().readJsonFileSync('myJsonFile.json');
            assert.deepEqual(actual, parsedJsonTestString);
        });

        it('an invalid JSON file', () => {
            const err = expectError(() => {
                new FileSystemService().readJsonFileSync('myFile.txt');
            });
            assert.equal(err.message, 'Invalid JSON file: "myFile.txt"');
        });
    });

    function mockUTF8FileSystemToReturn (toReturn) {
        return () => {
            // eslint-disable-next-line id-blacklist
            sandbox.stub(fs, 'readFile').callsFake((filePath, encoding, callback) => {
                try {
                    assert(_.has(toReturn, filePath));
                    assert.equal(encoding, 'utf8');
                } catch (err) {
                    callback(err);
                    return;
                }
                callback(null, toReturn[filePath]);
            });

            sandbox.stub(fs, 'readFileSync').callsFake((filePath, encoding) => {
                assert(_.has(toReturn, filePath));
                assert.equal(encoding, 'utf8');
                return toReturn[filePath];
            });
        };
    }

    function unmock () {
        sandbox.restore();
    }
});
